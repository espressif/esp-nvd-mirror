{"cve": {"id": "CVE-2024-49985", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-10-21T18:15:18.950", "lastModified": "2024-10-23T15:13:25.583", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: stm32f7: Do not prepare/unprepare clock during runtime suspend/resume\n\nIn case there is any sort of clock controller attached to this I2C bus\ncontroller, for example Versaclock or even an AIC32x4 I2C codec, then\nan I2C transfer triggered from the clock controller clk_ops .prepare\ncallback may trigger a deadlock on drivers/clk/clk.c prepare_lock mutex.\n\nThis is because the clock controller first grabs the prepare_lock mutex\nand then performs the prepare operation, including its I2C access. The\nI2C access resumes this I2C bus controller via .runtime_resume callback,\nwhich calls clk_prepare_enable(), which attempts to grab the prepare_lock\nmutex again and deadlocks.\n\nSince the clock are already prepared since probe() and unprepared in\nremove(), use simple clk_enable()/clk_disable() calls to enable and\ndisable the clock on runtime suspend and resume, to avoid hitting the\nprepare_lock mutex."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: i2c: stm32f7: No preparar/despreparar el reloj durante la suspensi\u00f3n/reanudaci\u00f3n en tiempo de ejecuci\u00f3n En caso de que haya alg\u00fan tipo de controlador de reloj conectado a este controlador de bus I2C, por ejemplo Versaclock o incluso un c\u00f3dec I2C AIC32x4, entonces una transferencia I2C activada desde la devoluci\u00f3n de llamada clk_ops .prepare del controlador de reloj puede activar un bloqueo en el mutex prepare_lock de drivers/clk/clk.c. Esto se debe a que el controlador de reloj primero toma el mutex prepare_lock y luego realiza la operaci\u00f3n de preparaci\u00f3n, incluido su acceso I2C. El acceso I2C reanuda este controlador de bus I2C a trav\u00e9s de la devoluci\u00f3n de llamada .runtime_resume, que llama a clk_prepare_enable(), que intenta tomar el mutex prepare_lock nuevamente y se bloquea. Dado que el reloj ya est\u00e1 preparado desde probe() y no preparado en remove(), use llamadas clk_enable()/clk_disable() simples para habilitar y deshabilitar el reloj en la suspensi\u00f3n y reanudaci\u00f3n del tiempo de ejecuci\u00f3n, para evitar alcanzar el mutex prepare_lock."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/048bbbdbf85e5e00258dfb12f5e368f908801d7b", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/1883cad2cc629ded4a3556c0bbb8b42533ad8764", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/22a1f8a5b56ba93d3e8b7a1dafa24e01c8bb48ba", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/894cd5f5fd9061983445bbd1fa3d81be43095344", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/9b8bc33ad64192f54142396470cc34ce539a8940", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/c2024b1a583ab9176c797ea1e5f57baf8d5e2682", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/fac3c9f7784e8184c0338e9f0877b81e55d3ef1c", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}}