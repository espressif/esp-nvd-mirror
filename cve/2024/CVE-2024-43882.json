{"cve": {"id": "CVE-2024-43882", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-08-21T01:15:12.340", "lastModified": "2024-08-21T12:30:33.697", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nexec: Fix ToCToU between perm check and set-uid/gid usage\n\nWhen opening a file for exec via do_filp_open(), permission checking is\ndone against the file's metadata at that moment, and on success, a file\npointer is passed back. Much later in the execve() code path, the file\nmetadata (specifically mode, uid, and gid) is used to determine if/how\nto set the uid and gid. However, those values may have changed since the\npermissions check, meaning the execution may gain unintended privileges.\n\nFor example, if a file could change permissions from executable and not\nset-id:\n\n---------x 1 root root 16048 Aug  7 13:16 target\n\nto set-id and non-executable:\n\n---S------ 1 root root 16048 Aug  7 13:16 target\n\nit is possible to gain root privileges when execution should have been\ndisallowed.\n\nWhile this race condition is rare in real-world scenarios, it has been\nobserved (and proven exploitable) when package managers are updating\nthe setuid bits of installed programs. Such files start with being\nworld-executable but then are adjusted to be group-exec with a set-uid\nbit. For example, \"chmod o-x,u+s target\" makes \"target\" executable only\nby uid \"root\" and gid \"cdrom\", while also becoming setuid-root:\n\n-rwxr-xr-x 1 root cdrom 16048 Aug  7 13:16 target\n\nbecomes:\n\n-rwsr-xr-- 1 root cdrom 16048 Aug  7 13:16 target\n\nBut racing the chmod means users without group \"cdrom\" membership can\nget the permission to execute \"target\" just before the chmod, and when\nthe chmod finishes, the exec reaches brpm_fill_uid(), and performs the\nsetuid to root, violating the expressed authorization of \"only cdrom\ngroup members can setuid to root\".\n\nRe-check that we still have execute permissions in case the metadata\nhas changed. It would be better to keep a copy from the perm-check time,\nbut until we can do that refactoring, the least-bad option is to do a\nfull inode_permission() call (under inode lock). It is understood that\nthis is safe against dead-locks, but hardly optimal."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: exec: corrige ToCToU entre la verificaci\u00f3n permanente y el uso de set-uid/gid Al abrir un archivo para exec a trav\u00e9s de do_filp_open(), la verificaci\u00f3n de permisos se realiza con los metadatos del archivo en ese momento, y en caso de \u00e9xito, se devuelve un puntero de archivo. Mucho m\u00e1s adelante en la ruta del c\u00f3digo execve(), los metadatos del archivo (espec\u00edficamente modo, uid y gid) se utilizan para determinar si y c\u00f3mo configurar uid y gid. Sin embargo, es posible que esos valores hayan cambiado desde la verificaci\u00f3n de permisos, lo que significa que la ejecuci\u00f3n puede obtener privilegios no deseados. Por ejemplo, si un archivo pudiera cambiar los permisos de ejecutable y no de set-id: ---------x 1 root root 16048 7 de agosto 13:16 destino a set-id y no ejecutable: ---S ------ 1 root root 16048 7 de agosto 13:16 target es posible obtener privilegios de root cuando la ejecuci\u00f3n no deber\u00eda haberse permitido. Si bien esta condici\u00f3n de ejecuci\u00f3n es poco com\u00fan en escenarios del mundo real, se ha observado (y se ha demostrado que es explotable) cuando los administradores de paquetes actualizan los bits setuid de los programas instalados. Dichos archivos comienzan siendo ejecutables mundialmente, pero luego se ajustan para que sean ejecutables en grupo con un bit set-uid. Por ejemplo, \"chmod ox,u+s target\" hace que \"target\" sea ejecutable s\u00f3lo mediante uid \"root\" y gid \"cdrom\", y al mismo tiempo se convierte en setuid-root: -rwxr-xr-x 1 root cdrom 16048 7 de agosto de 13: 16 objetivo se convierte en: -rwsr-xr-- 1 cdrom ra\u00edz 16048 7 de agosto 13:16 objetivo Pero competir con el chmod significa que los usuarios sin membres\u00eda del grupo \"cdrom\" pueden obtener permiso para ejecutar \"destino\" justo antes del chmod, y cuando el chmod finaliza, el ejecutivo llega a brpm_fill_uid() y realiza el setuid como root, violando la autorizaci\u00f3n expresa de \"s\u00f3lo los miembros del grupo cdrom pueden setuid como root\". Vuelva a verificar que todav\u00eda tengamos permisos de ejecuci\u00f3n en caso de que los metadatos hayan cambiado. Ser\u00eda mejor conservar una copia del momento de verificaci\u00f3n permanente, pero hasta que podamos hacer esa refactorizaci\u00f3n, la opci\u00f3n menos mala es hacer una llamada completa a inode_permission() (bajo bloqueo de inodo). Se entiende que esto es seguro contra bloqueos mutuos, pero no es \u00f3ptimo."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/15469d46ba34559bfe7e3de6659115778c624759", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/368f6985d46657b8b466a421dddcacd4051f7ada", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/90dfbba89ad4f0d9c9744ecbb1adac4aa2ff4f3e", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/9b424c5d4130d56312e2a3be17efb0928fec4d64", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/d2a2a4714d80d09b0f8eb6438ab4224690b7121e", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/d5c3c7e26275a2d83b894d30f7582a42853a958f", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f50733b45d865f91db90919f8311e2127ce5a0cb", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f6cfc6bcfd5e1cf76115b6450516ea4c99897ae1", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}}