{"cve": {"id": "CVE-2024-46845", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-09-27T13:15:16.397", "lastModified": "2024-09-30T12:45:57.823", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Only clear timer if a kthread exists\n\nThe timerlat tracer can use user space threads to check for osnoise and\ntimer latency. If the program using this is killed via a SIGTERM, the\nthreads are shutdown one at a time and another tracing instance can start\nup resetting the threads before they are fully closed. That causes the\nhrtimer assigned to the kthread to be shutdown and freed twice when the\ndying thread finally closes the file descriptors, causing a use-after-free\nbug.\n\nOnly cancel the hrtimer if the associated thread is still around. Also add\nthe interface_lock around the resetting of the tlat_var->kthread.\n\nNote, this is just a quick fix that can be backported to stable. A real\nfix is to have a better synchronization between the shutdown of old\nthreads and the starting of new ones."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tracing/timerlat: Solo borra el temporizador si existe un kthread El tracer timerlat puede usar subprocesos del espacio de usuario para verificar el ruido de os y la latencia del temporizador. Si el programa que lo usa se elimina mediante un SIGTERM, los subprocesos se cierran uno a la vez y otra instancia de tracer puede comenzar a reiniciar los subprocesos antes de que se cierren por completo. Eso hace que el hrtimer asignado al kthread se cierre y se libere dos veces cuando el subproceso que muere finalmente cierra los descriptores de archivo, lo que causa un error de uso despu\u00e9s de liberaci\u00f3n. Solo cancele el hrtimer si el subproceso asociado a\u00fan est\u00e1 presente. Tambi\u00e9n agregue el interface_lock alrededor del reinicio de tlat_var-&gt;kthread. Tenga en cuenta que esto es solo una soluci\u00f3n r\u00e1pida que se puede trasladar a estable. Una soluci\u00f3n real es tener una mejor sincronizaci\u00f3n entre el apagado de subprocesos antiguos y el inicio de nuevos."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/8a9d0d405159e9c796ddf771f7cff691c1a2bc1e", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/8c72f0b2c45f21cb8b00fc37f79f632d7e46c2ed", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/e6a53481da292d970d1edf0d8831121d1c5e2f0d", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}}