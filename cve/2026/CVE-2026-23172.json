{"cve": {"id": "CVE-2026-23172", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2026-02-14T16:15:57.457", "lastModified": "2026-02-18T17:52:44.520", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: wwan: t7xx: fix potential skb->frags overflow in RX path\n\nWhen receiving data in the DPMAIF RX path,\nthe t7xx_dpmaif_set_frag_to_skb() function adds\npage fragments to an skb without checking if the number of\nfragments has exceeded MAX_SKB_FRAGS. This could lead to a buffer overflow\nin skb_shinfo(skb)->frags[] array, corrupting adjacent memory and\npotentially causing kernel crashes or other undefined behavior.\n\nThis issue was identified through static code analysis by comparing with a\nsimilar vulnerability fixed in the mt76 driver commit b102f0c522cf (\"mt76:\nfix array overflow on receiving too many fragments for a packet\").\n\nThe vulnerability could be triggered if the modem firmware sends packets\nwith excessive fragments. While under normal protocol conditions (MTU 3080\nbytes, BAT buffer 3584 bytes),\na single packet should not require additional\nfragments, the kernel should not blindly trust firmware behavior.\nMalicious, buggy, or compromised firmware could potentially craft packets\nwith more fragments than the kernel expects.\n\nFix this by adding a bounds check before calling skb_add_rx_frag() to\nensure nr_frags does not exceed MAX_SKB_FRAGS.\n\nThe check must be performed before unmapping to avoid a page leak\nand double DMA unmap during device teardown."}, {"lang": "es", "value": "En el kernel de Linux, la siguiente vulnerabilidad ha sido resuelta:\n\nnet: wwan: t7xx: corrige un potencial desbordamiento de skb-&gt;frags en la ruta RX\n\nAl recibir datos en la ruta RX de DPMAIF, la funci\u00f3n t7xx_dpmaif_set_frag_to_skb() a\u00f1ade fragmentos de p\u00e1gina a un skb sin comprobar si el n\u00famero de fragmentos ha excedido MAX_SKB_FRAGS. Esto podr\u00eda conducir a un desbordamiento de b\u00fafer en el array skb_shinfo(skb)-&gt;frags[], corrompiendo memoria adyacente y potencialmente causando fallos del kernel u otro comportamiento indefinido.\n\nEste problema fue identificado a trav\u00e9s de an\u00e1lisis de c\u00f3digo est\u00e1tico comparando con una vulnerabilidad similar corregida en el commit b102f0c522cf del controlador mt76 ('mt76: corrige el desbordamiento del array al recibir demasiados fragmentos para un paquete').\n\nLa vulnerabilidad podr\u00eda ser activada si el firmware del m\u00f3dem env\u00eda paquetes con fragmentos excesivos. Si bien bajo condiciones normales del protocolo (MTU 3080 bytes, b\u00fafer BAT 3584 bytes), un solo paquete no deber\u00eda requerir fragmentos adicionales, el kernel no deber\u00eda confiar ciegamente en el comportamiento del firmware. Firmware malicioso, con errores o comprometido podr\u00eda potencialmente crear paquetes con m\u00e1s fragmentos de los que el kernel espera.\n\nSolucione esto a\u00f1adiendo una comprobaci\u00f3n de l\u00edmites antes de llamar a skb_add_rx_frag() para asegurar que nr_frags no exceda MAX_SKB_FRAGS.\n\nLa comprobaci\u00f3n debe realizarse antes de desmapear para evitar una fuga de p\u00e1gina y un doble desmapeo DMA durante el desmontaje del dispositivo."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/2a0522f564acd34442652ea083091c329fa7c5d5", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/2c0fb0f60bc1545c52da61bc6bd4855c1e7814ba", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/af4b8577d0b388cc3d0039eb0cdd9ca5bbbc9276", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f0813bcd2d9d97fdbdf2efb9532ab03ae92e99e6", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f9747a7521a48afded5bff2faf1f2dcfff48c577", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}}