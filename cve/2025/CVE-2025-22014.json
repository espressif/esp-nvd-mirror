{"cve": {"id": "CVE-2025-22014", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2025-04-08T09:15:25.783", "lastModified": "2025-04-08T18:13:53.347", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: pdr: Fix the potential deadlock\n\nWhen some client process A call pdr_add_lookup() to add the look up for\nthe service and does schedule locator work, later a process B got a new\nserver packet indicating locator is up and call pdr_locator_new_server()\nwhich eventually sets pdr->locator_init_complete to true which process A\nsees and takes list lock and queries domain list but it will timeout due\nto deadlock as the response will queued to the same qmi->wq and it is\nordered workqueue and process B is not able to complete new server\nrequest work due to deadlock on list lock.\n\nFix it by removing the unnecessary list iteration as the list iteration\nis already being done inside locator work, so avoid it here and just\ncall schedule_work() here.\n\n       Process A                        Process B\n\n                                     process_scheduled_works()\npdr_add_lookup()                      qmi_data_ready_work()\n process_scheduled_works()             pdr_locator_new_server()\n                                         pdr->locator_init_complete=true;\n   pdr_locator_work()\n    mutex_lock(&pdr->list_lock);\n\n     pdr_locate_service()                  mutex_lock(&pdr->list_lock);\n\n      pdr_get_domain_list()\n       pr_err(\"PDR: %s get domain list\n               txn wait failed: %d\\n\",\n               req->service_name,\n               ret);\n\nTimeout error log due to deadlock:\n\n\"\n PDR: tms/servreg get domain list txn wait failed: -110\n PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110\n\"\n\nThanks to Bjorn and Johan for letting me know that this commit also fixes\nan audio regression when using the in-kernel pd-mapper as that makes it\neasier to hit this race. [1]"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: soc: qcom: pdr: Corrige el posible bloqueo cuando alg\u00fan proceso de cliente A llama a pdr_add_lookup() para agregar la b\u00fasqueda para el servicio y realiza el trabajo del localizador de programaci\u00f3n, m\u00e1s tarde un proceso B obtiene un nuevo paquete de servidor que indica que el localizador est\u00e1 activo y llama a pdr_locator_new_server() que finalmente establece pdr-&gt;locator_init_complete en verdadero, lo que hace que el proceso A vea y tome el bloqueo de lista y consulte la lista de dominios, pero se agotar\u00e1 el tiempo de espera debido al bloqueo, ya que la respuesta se pondr\u00e1 en cola en el mismo qmi-&gt;wq y se ordenar\u00e1 workqueue y el proceso B no puede completar el nuevo trabajo de solicitud del servidor debido al bloqueo en el bloqueo de lista. Arr\u00e9glelo eliminando la iteraci\u00f3n de lista innecesaria, ya que la iteraci\u00f3n de lista ya se est\u00e1 realizando dentro del trabajo del localizador, as\u00ed que ev\u00edtelo aqu\u00ed y simplemente llame a schedule_work() aqu\u00ed. Proceso A Proceso B process_scheduled_works() pdr_add_lookup() qmi_data_ready_work() process_scheduled_works() pdr_locator_new_server() pdr-&gt;locator_init_complete=true; pdr_locator_work() mutex_lock(&amp;pdr-&gt;list_lock); pdr_locate_service() mutex_lock(&amp;pdr-&gt;list_lock); pdr_get_domain_list() pr_err(\"PDR: %s error en la espera de la transacci\u00f3n para obtener la lista de dominios: %d\\n\", req-&gt;service_name, ret); Registro de errores de tiempo de espera debido a un bloqueo: \"PDR: tms/servreg get domain list txn wait fallo: -110 PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110\" Gracias a Bjorn y Johan por informarme que esta confirmaci\u00f3n tambi\u00e9n corrige una regresi\u00f3n de audio al usar el pd-mapper dentro del kernel, ya que eso hace que sea m\u00e1s f\u00e1cil alcanzar esta ejecuci\u00f3n. [1]"}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/02612f1e4c34d94d6c8ee75bf7d254ed697e22d4", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/0a566a79aca9851fae140536e0fc5b0853c90a90", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/2eeb03ad9f42dfece63051be2400af487ddb96d2", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f2bbfd50e95bc117360f0f59e629aa03d821ebd6", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/f4489260f5713c94e1966e5f20445bff262876f4", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}}